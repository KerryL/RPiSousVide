// File:  autoTuner.h
// Date:  9/19/2013
// Auth:  K. Loux
// Copy:  (c) Kerry Loux 2013
// Desc:  Auto-tuner for PI + FF controller for heated tank.  This performs some
//        system identification, sends results to the specified output stream,
//        and makes recommendations for Kp, Ti, and Kf.  Details on assumptions,
//        model form and gain selection criteria are below.
//
// Assumptions:
//   - Fluid is well mixed, but no heat is added via mixing
//   - Ambient temperature is constant (i.e. we're not modeling the increase in
//     room temperature as the tank looses heat)
//   - Constant fluid properties vs. temperature
//   - No flow in or out of tank
//   - Constant rate of heat transfer through all tank surfaces (i.e. effect of
//     tank resting on floor or air trapped at top of tank is not captured)
// 
// System Model:
// We assume the rate of change of the temperature obeys the following equation:
//
//          h * A * (Tamb - Ttank) + H
//  dT/dt = --------------------------
//               rho * V * Cp
//
// where (note that units are provided, but it is permissible to use different
// units, as long as all units are consistent):
//   h     = tank-room heat transfer coefficient [BTU/deg F-sec-ft^2]
//   A     = heat transfer surface area          [ft^2]
//   Tamb  = ambient room temperature            [deg F]
//   Ttank = current tank temperature            [deg F]
//   H     = power generated by heater           [BTU/sec]
//   rho   = density of fluid                    [lb/ft^3]
//   V     = volume of fluid in tank             [ft^3]
//   Cp    = specific heat of fluid in tank      [BTU/lb-deg F]
//
// With simple measurements, we will be unable to identify all of the above model
// parameters.  Instead, we can group parameters together to create just two bulk
// parameters:
//   c1 = h * A / (rho * V * Cp) [1/sec]
//   c2 = 1 / (rho * V * Cp)     [deg F/BTU]
//
// We can convert the differential equation (with the above substitutions) into
// a state-space model, and also a transfer function.  We use the state-space
// form for simulating the time response, and the transfer function for deciding
// how to select gains.
//
// The state-space model looks like this:
//   A = [-c1 c1 ],  B = [ c2 ],  C = [ 1 0 ],  D = 0,  x = [ Ttank ]
//       [ 0  0  ]       [ 0  ]                             [ Tamb  ]
//
// The equivalent transfer function is:
//          Y(s)      c2 * s
//   G(s) = ---- = ------------
//          U(s)   s^2 + c1 * s
//
// The PI controller takes the following form:
//          U(s)
//   C(s) = ---- = Kp * (1 + 1 / (Ti * s))
//          E(s)
//
// The system block diagram looks like this:
//
//                                  +     U(s)
//         ---------->[ Kf * s ]----->o-------->[ G(s) ]------> Y(s)
//         |                        + ^                   |
//         | +     E(s)               |                   |
//   R(s) --->o--------->[ C(s) ]-----|                   |
//          - ^                                           |
//            |--------------------------------------------
//
// Note that the feed-forward path is shown with a pure integrate - in practice,
// a derivative filter is used.  We neglect the entire feed-forward path for most
// of this analysis, so we don't bother including the proper feed-forward transfer
// function.  We use E(s) to indicate the error, which is Y(s) - R(s).
//
// The closed-loop transfer function (neglecting the feed-forward term - more
// on this can be found in the ComputeRecommendedGains method in autoTune.cpp) is then:
//
//   Y(s)              Kp * s + Kp / Ti
//   ---- = ---------------------------------------
//   R(s)   s^2 / c2 + (Kp + c1 / c2) * s + Kp / Ti

#ifndef AUTO_TUNER_H_
#define AUTO_TUNER_H_

// Standard C++ headers
#include <vector>
#include <iostream>
#include <ostream>

class AutoTuner
{
public:
	AutoTuner(std::ostream &outStream = std::cout);

	// Data passed to this method must be temperatures and time for a period where
	// the heater is on at 100% capacity.  More data is better, but a reasonable
	// minimum might be a period where the temperature increases about 10 deg F.
	bool ProcessAutoTuneData(const std::vector<double> &time,
		const std::vector<double> &temperature, double desiredBandwidth = 0.01,
		double desiredDamping = 5.0, double maxRateScale = 0.95,
		double referenceTemperature = 180.0, double feedForwardScale = 0.8,
		unsigned int ambTempSegments = 20);
		
	static double GetMinimumAutoTuneTime(double sampleRate,
		unsigned int ambTempSegments = 20);// [sec]

	double GetC1(void) const { return c1; };// [1 / sec]
	double GetC2(void) const { return c2; };// [deg F/BTU]
	double GetKp(void) const { return kp; };// [%/deg F]
	double GetTi(void) const { return ti; };// [sec]
	double GetKf(void) const { return kf; };// [%-sec/deg F]
	double GetMaxHeatRate(void) const { return maxHeatRate; };// [deg F/sec]
	double GetAmbientTemperature(void) const { return ambientTemperature; };// [deg F]

	// Open-loop simulation
	bool GetSimulatedOpenLoopResponse(const std::vector<double> &time,
		const std::vector<double> &control, std::vector<double> &temperature) const;
	bool GetSimulatedOpenLoopResponse(const std::vector<double> &time,
		const std::vector<double> &control, std::vector<double> &temperature,
		double initialTemperature) const;
	bool GetSimulatedOpenLoopResponse(const std::vector<double> &time,
		const std::vector<double> &control, std::vector<double> &temperature,
		double initialTemperature, double ambientTemperature) const;
	double GetSimulatedOpenLoopResponse(double deltaT, double control,
		double tankTemperature, double ambientTemperature) const;
	double PredictRateOfChange(double control, double tankTemperature,
		double ambientTemperature) const;

private:
	std::ostream &outStream;
	static const double ignoreInitialTime;// [sec]

	void InitializeMembers(void);

	// Outputs generated by autotuning
	double c1, c2;
	double kp, ti, kf;
	double maxHeatRate;
	double ambientTemperature;

	bool MembersAreValid(void) const;

	bool ComputeC1(const std::vector<double> &time, const std::vector<double> &dTdt);
	bool ComputeC2(const std::vector<double> &time, const std::vector<double> &dTdt);
	void ComputeAmbientTemperature(const std::vector<double> &time,
		const std::vector<double> &temperature, unsigned int segments);
	void ComputeMaxHeatRate(double maxRateScale, double referenceTemperature);
	void ComputeRecommendedGains(double desiredBandwidth, double desiredDamping,
		double feedForwardScale);
};

#endif// AUTO_TUNER_H_
