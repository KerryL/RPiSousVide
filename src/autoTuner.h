// File:  autoTuner.h
// Date:  9/19/2013
// Auth:  K. Loux
// Copy:  (c) Kerry Loux 2013
// Desc:  Auto-tuner for PI + FF controller for heated tank.  This performs some
//        system identification, sends results to the specified output stream,
//        and makes recommendations for Kp, Ti, and Kf.  Details on assumptions,
//        model form and gain selection criteria are below.
//
// Assumptions:
//   - Fluid is well mixed, but no heat is added via mixing
//   - Ambient temperature is constant (i.e. we're not modeling the increase in
//     room temperature as the tank looses heat)
//   - Constant fluid properties vs. temperature
//   - No flow in or out of tank
//   - Constant rate of heat transfer through all tank surfaces (i.e. effect of
//     tank resting on floor or air trapped at top of tank is not captured)
//   - Heater heat rate has a first-order lag
// 
// System Model:
// We assume the rate of change of the temperature obeys the following equation:
//
//          h * A * (Tamb - Ttank) + H * (1 - tau * dH/dt)
//  dT/dt = ----------------------------------------------
//                         rho * V * Cp
//
// where (note that units are provided, but it is permissible to use different
// units, as long as all units are consistent):
//   h     = tank-room heat transfer coefficient [BTU/deg F-sec-ft^2]
//   A     = heat transfer surface area          [ft^2]
//   Tamb  = ambient room temperature            [deg F]
//   Ttank = current tank temperature            [deg F]
//   H     = power generated by heater           [BTU/sec]
//   rho   = density of fluid                    [lb/ft^3]
//   V     = volume of fluid in tank             [ft^3]
//   Cp    = specific heat of fluid in tank      [BTU/lb-deg F]
//   tau   = heater time constant                [sec]
//
// With simple measurements, we will be unable to identify all of the above
// model parameters.  Instead, we can group parameters together to create just
// two bulk parameters (plus tau):
//   c1   = h * A / (rho * V * Cp)     [1/sec]
//   c2   = 1 / (rho * V * Cp)         [deg F/BTU]
//
// We can convert the differential equation (with the above substitutions) into
// a state-space model, and also a transfer function.  We use the state-space
// form for simulating the time response, and the transfer function for deciding
// how to select gains.
//
// The state-space model looks like this:
//   A = [-c1 c1   c2  ],  B = [   0   ],  C = [ 1 0 0 ],  D = 0,  x = [ Ttank ]
//       [ 0  0    0   ]       [   0   ]                               [ Tamb  ]
//       [ 0  0 -1/tau ]       [ 1/tau ]                               [   H   ]
//
// The equivalent transfer function is:
//          Y(s)                  c2
//   G(s) = ---- = -----------------------------------
//          U(s)   tau * s^2 + (c1 * tau + 1) * s + c1
//
// The PI controller takes the following form:
//          U(s)
//   C(s) = ---- = Kp * (1 + 1 / (Ti * s))
//          E(s)
//
// The system block diagram looks like this:
//
//                                  +     U(s)
//         ---------->[ Kf * s ]----->o-------->[ G(s) ]------> Y(s)
//         |                        + ^                   |
//         | +     E(s)               |                   |
//   R(s) --->o--------->[ C(s) ]-----|                   |
//          - ^                                           |
//            |--------------------------------------------
//
// Note that the feed-forward path is shown with a pure integrator - in
// practice, a derivative filter is used.  We neglect the entire feed-forward
// path for most of this analysis, so we don't bother including the proper feed-
// forward transfer function.  We use E(s) to indicate the error, which is:
// Y(s) - R(s).
//
// The closed-loop transfer function (neglecting the feed-forward term - more on
// this can be found in the ComputeRecommendedGains method in autoTune.cpp) is
// then:
//
//   Y(s)                   c2 * Kp * s + c2 * Kp / Ti
//   ---- = --------------------------------------------------------------------
//   R(s)   tau * s^3 + (c1 * tau + 1) * s^2 + (c1 + c2 * Kp) * s + c2 * Kp / Ti

#ifndef AUTO_TUNER_H_
#define AUTO_TUNER_H_

// Standard C++ headers
#include <vector>
#include <iostream>
#include <ostream>

// Local headers
#include "matrix.h"

class AutoTuner
{
public:
	AutoTuner(std::ostream &outStream = std::cout);

	// Data passed to this method must be temperatures and time for a period where
	// the heater is on at 100% capacity.  More data is better, but a reasonable
	// minimum might be a period where the temperature increases about 10 deg F.
	bool ProcessAutoTuneData(const std::vector<double> &time,
		const std::vector<double> &temperature, double desiredBandwidth = 0.01,
		double desiredDamping = 5.0, double maxRateScale = 0.95,
		double referenceTemperature = 180.0, double feedForwardScale = 0.8);
		
	static double GetMinimumAutoTuneTime(double sampleRate);// [sec]
	//static double GetSwitchTime(void) { return switchTime; };// [sec]

	double GetC1(void) const { return c1; };// [1 / sec]
	double GetC2(void) const { return c2; };// [deg F/BTU]
	double GetTau(void) const { return tau; };// [sec]
	double GetKp(void) const { return kp; };// [%/deg F]
	double GetTi(void) const { return ti; };// [sec]
	double GetKf(void) const { return kf; };// [%-sec/deg F]
	double GetMaxHeatRate(void) const { return maxHeatRate; };// [deg F/sec]
	double GetAmbientTemperature(void) const { return ambientTemperature; };// [deg F]

	// Open-loop simulation
	bool GetSimulatedOpenLoopResponse(const std::vector<double> &time,
		const std::vector<double> &control, std::vector<double> &temperature);
	bool GetSimulatedOpenLoopResponse(const std::vector<double> &time,
		const std::vector<double> &control, std::vector<double> &temperature,
		double initialTemperature);
	bool GetSimulatedOpenLoopResponse(const std::vector<double> &time,
		const std::vector<double> &control, std::vector<double> &temperature,
		double initialTemperature, double ambientTemperature,
		double initialHeatOutput = 0.0);

private:
	std::ostream &outStream;

	void InitializeMembers(void);

	//static double switchTime;// [sec]

	// Outputs generated by autotuning
	double c1, c2, tau;
	double kp, ti, kf;
	double maxHeatRate;
	double ambientTemperature;

	// Methods to check auto-tune results
	bool MembersAreValid(void) const;
	bool SystemParametersAreValid(void) const;
	bool ModelParametersAreValid(void) const;
	bool ControllerParametersAreValid(void) const;

	// System identification methods
	bool ComputeRegressionCoefficients(const std::vector<double> &time,
		const std::vector<double> &temperature, Matrix &x);
	bool ComputeParametersFromCoefficients(const Matrix &x, const double &sampleTime);
	bool ComputeAmbientTemperature(const std::vector<double> &time,
		const std::vector<double> &temperature);

	double ComputeMeanSampleTime(const std::vector<double> &time) const;
	double ComputeInputSignal(double time) const;
	double SolveForC1(double x1, double x2, double ts, bool plusSolution) const;
	double SolveForC2(double x0, double ts) const;
	double SolveForTau(double x2, double ts) const;

	// "Tuning" methods
	void ComputeMaxHeatRate(double maxRateScale, double referenceTemperature);
	void ComputeRecommendedGains(double desiredBandwidth, double desiredDamping,
		double feedForwardScale);
	
	// Simulation objects and methods
	Matrix system, input, output, state;
	void BuildSimulationMatrices(double initialTemperature,
		double ambientTemperature, double initialHeatLevel);
	void ComputeNextTimeStep(const double &control, const double &deltaTime);
};

#endif// AUTO_TUNER_H_
